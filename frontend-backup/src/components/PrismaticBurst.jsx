import { useEffect, useRef } from "react";
import {
  Renderer,
  Program,
  Mesh,
  Triangle,
  Texture,
} from "https://cdn.jsdelivr.net/gh/framer-university/components/npm-bundles/ogl-prism.js";

const vertexShader = `#version 300 es
in vec2 position;
in vec2 uv;
out vec2 vUv;
void main() {
    vUv = uv;
    gl_Position = vec4(position, 0.0, 1.0);
}`;

const fragmentShader = `#version 300 es
precision highp float;
precision highp int;

out vec4 fragColor;

uniform vec2  uResolution;
uniform float uTime;

uniform float uIntensity;
uniform float uSpeed;
uniform int   uAnimType;
uniform vec2  uMouse;
uniform int   uColorCount;
uniform float uDistort;
uniform vec2  uOffset;
uniform sampler2D uGradient;
uniform float uNoiseAmount;
uniform int   uRayCount;
uniform int   uMaxIterations;

float hash21(vec2 p){
    p = floor(p);
    float f = 52.9829189 * fract(dot(p, vec2(0.065, 0.005)));
    return fract(f);
}

mat2 rot30(){ return mat2(0.8, -0.5, 0.5, 0.8); }

float layeredNoise(vec2 fragPx){
    vec2 p = mod(fragPx + vec2(uTime * 30.0, -uTime * 21.0), 1024.0);
    vec2 q = rot30() * p;
    float n = 0.0;
    n += 0.40 * hash21(q);
    n += 0.25 * hash21(q * 2.0 + 17.0);
    n += 0.20 * hash21(q * 4.0 + 47.0);
    n += 0.10 * hash21(q * 8.0 + 113.0);
    n += 0.05 * hash21(q * 16.0 + 191.0);
    return n;
}

vec3 rayDir(vec2 frag, vec2 res, vec2 offset, float dist){
    float focal = res.y * max(dist, 1e-3);
    return normalize(vec3(2.0 * (frag - offset) - res, focal));
}

float edgeFade(vec2 frag, vec2 res, vec2 offset){
    vec2 toC = frag - 0.5 * res - offset;
    float r = length(toC) / (0.5 * min(res.x, res.y));
    float x = clamp(r, 0.0, 1.0);
    float q = x * x * x * (x * (x * 6.0 - 15.0) + 10.0);
    float s = q * 0.5;
    s = pow(s, 1.5);
    float tail = 1.0 - pow(1.0 - s, 2.0);
    s = mix(s, tail, 0.2);
    float dn = (layeredNoise(frag * 0.15) - 0.5) * 0.0015 * s;
    return clamp(s + dn, 0.0, 1.0);
}

mat3 rotX(float a){ float c = cos(a), s = sin(a); return mat3(1.0,0.0,0.0, 0.0,c,-s, 0.0,s,c); }
mat3 rotY(float a){ float c = cos(a), s = sin(a); return mat3(c,0.0,s, 0.0,1.0,0.0, -s,0.0,c); }
mat3 rotZ(float a){ float c = cos(a), s = sin(a); return mat3(c,-s,0.0, s,c,0.0, 0.0,0.0,1.0); }

vec3 sampleGradient(float t){
    t = clamp(t, 0.0, 1.0);
    return texture(uGradient, vec2(t, 0.5)).rgb;
}

vec2 rot2(vec2 v, float a){
    float s = sin(a), c = cos(a);
    return mat2(c, -s, s, c) * v;
}

float bendAngle(vec3 q, float t){
    float a = 0.8 * sin(q.x * 0.55 + t * 0.6)
            + 0.7 * sin(q.y * 0.50 - t * 0.5)
            + 0.6 * sin(q.z * 0.60 + t * 0.7);
    return a;
}

void main(){
    vec2 frag = gl_FragCoord.xy;
    float t = uTime * uSpeed;
    float jitterAmp = 0.1 * clamp(uNoiseAmount, 0.0, 1.0);
    vec3 dir = rayDir(frag, uResolution, uOffset, 1.0);
    float marchT = 0.0;
    vec3 col = vec3(0.0);
    float n = layeredNoise(frag);
    vec4 c = cos(t * 0.2 + vec4(0.0, 33.0, 11.0, 0.0));
    mat2 M2 = mat2(c.x, c.y, c.z, c.w);
    float amp = clamp(uDistort, 0.0, 50.0) * 0.15;

    mat3 rot3dMat = mat3(1.0);
    if(uAnimType == 1){
      vec3 ang = vec3(t * 0.31, t * 0.21, t * 0.17);
      rot3dMat = rotZ(ang.z) * rotY(ang.y) * rotX(ang.x);
    }
    mat3 hoverMat = mat3(1.0);
    if(uAnimType == 2){
      vec2 m = uMouse * 2.0 - 1.0;
      vec3 ang = vec3(m.y * 0.6, m.x * 0.6, 0.0);
      hoverMat = rotY(ang.y) * rotX(ang.x);
    }

    for (int i = 0; i < uMaxIterations; ++i) {
        vec3 P = marchT * dir;
        P.z -= 2.0;
        float rad = length(P);
        vec3 Pl = P * (10.0 / max(rad, 1e-6));

        if(uAnimType == 0){
            Pl.xz *= M2;
        } else if(uAnimType == 1){
      Pl = rot3dMat * Pl;
        } else {
      Pl = hoverMat * Pl;
        }

        float stepLen = min(rad - 0.3, n * jitterAmp) + 0.1;

        float grow = smoothstep(0.35, 3.0, marchT);
        float a1 = amp * grow * bendAngle(Pl * 0.6, t);
        float a2 = 0.5 * amp * grow * bendAngle(Pl.zyx * 0.5 + 3.1, t * 0.9);
        vec3 Pb = Pl;
        Pb.xz = rot2(Pb.xz, a1);
        Pb.xy = rot2(Pb.xy, a2);

        float rayPattern = smoothstep(
            0.5, 0.7,
            sin(Pb.x + cos(Pb.y) * cos(Pb.z)) *
            sin(Pb.z + sin(Pb.y) * cos(Pb.x + t))
        );

        if (uRayCount > 0) {
            float ang = atan(Pb.y, Pb.x);
            float comb = cos(float(uRayCount) * ang);
            rayPattern = rayPattern * smoothstep(-0.5, 0.5, comb);
        }

        vec3 spectralDefault = 1.0 + vec3(
            cos(marchT * 3.0 + 0.0),
            cos(marchT * 3.0 + 1.0),
            cos(marchT * 3.0 + 2.0)
        );

        float saw = fract(marchT * 0.25);
        float tRay = saw * saw * (3.0 - 2.0 * saw);
        vec3 userGradient = 2.0 * sampleGradient(tRay);
        vec3 spectral = (uColorCount > 0) ? userGradient : spectralDefault;
        vec3 base = (0.05 / (0.4 + stepLen))
                  * smoothstep(5.0, 0.0, rad)
                  * spectral;

        col += base * rayPattern;
        marchT += stepLen;
    }

    col *= edgeFade(frag, uResolution, uOffset);
    col *= uIntensity;

    fragColor = vec4(clamp(col, 0.0, 1.0), 1.0);
}`;

const defaults = {
  intensity: 8,
  speed: 0.45,
  animationType: "rotate3d",
  colors: ["#ffd1ff", "#92fff8", "#4f65ff"],
  distort: 35,
  offset: { x: 0, y: 0 },
  rayCount: 28,
  hoverDampness: 0.35,
  maxFPS: 60,
  quality: "high",
  mixBlendMode: "screen",
  noiseAmount: 0.8,
};

const mapIntensity = (v) => ((v - 1) / 9) * 5;
const mapSpeed = (v) => v * 2;
const mapDistort = (v) => (v / 100) * 50;

function colorStringToVec4(input) {
  const hex = input.replace("#", "");
  if (hex.length === 6) {
    return [
      parseInt(hex.slice(0, 2), 16) / 255,
      parseInt(hex.slice(2, 4), 16) / 255,
      parseInt(hex.slice(4, 6), 16) / 255,
      1,
    ];
  }
  return [1, 1, 1, 1];
}

const deviceDpr = () => (typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1);

const qualityPreset = () => {
  const dpr = deviceDpr();
  return {
    low: { maxIterations: 20, dpr: 1, frameSkip: 2 },
    medium: { maxIterations: 32, dpr: Math.min(dpr, 1.5), frameSkip: 1 },
    high: { maxIterations: 60, dpr: Math.min(dpr, 2), frameSkip: 0 },
  };
};

class PrismEngine {
  constructor(container, options = {}) {
    this.container = container;
    this.opts = { ...defaults, ...options };
    this.mouseTarget = [0.5, 0.5];
    this.mouseSmooth = [0.5, 0.5];
    this.frameSkip = 0;
    this.lastFrame = 0;
    this.accumTime = 0;
    this.visible = true;
    this.setup();
  }

  setup() {
    const presets = qualityPreset();
    const perf = presets[this.opts.quality] ?? presets.high;
    this.perf = perf;

    this.renderer = new Renderer({
      dpr: perf.dpr,
      alpha: false,
      antialias: false,
    });

    const { gl } = this.renderer;
    gl.canvas.style.position = "absolute";
    gl.canvas.style.inset = "0";
    gl.canvas.style.width = "100%";
    gl.canvas.style.height = "100%";
    gl.canvas.style.mixBlendMode =
      this.opts.mixBlendMode && this.opts.mixBlendMode !== "normal"
        ? this.opts.mixBlendMode
        : "";

    this.container.appendChild(gl.canvas);

    const white = new Uint8Array([255, 255, 255, 255]);
    const gradientTex = new Texture(gl, {
      image: white,
      width: 1,
      height: 1,
      generateMipmaps: false,
      flipY: false,
    });

    gradientTex.minFilter = gl.LINEAR;
    gradientTex.magFilter = gl.LINEAR;
    gradientTex.wrapS = gl.CLAMP_TO_EDGE;
    gradientTex.wrapT = gl.CLAMP_TO_EDGE;

    this.gradientTex = gradientTex;

    this.program = new Program(gl, {
      vertex: vertexShader,
      fragment: fragmentShader,
      uniforms: {
        uResolution: { value: [1, 1] },
        uTime: { value: 0 },
        uIntensity: { value: mapIntensity(this.opts.intensity) },
        uSpeed: { value: mapSpeed(this.opts.speed) },
        uAnimType: { value: this.animTypeIndex() },
        uMouse: { value: [0.5, 0.5] },
        uColorCount: { value: 0 },
        uDistort: { value: mapDistort(this.opts.distort) },
        uOffset: { value: [0, 0] },
        uGradient: { value: gradientTex },
        uNoiseAmount: { value: this.opts.noiseAmount },
        uRayCount: { value: this.opts.rayCount },
        uMaxIterations: { value: perf.maxIterations },
      },
    });

    const triangle = new Triangle(gl);
    this.mesh = new Mesh(gl, { geometry: triangle, program: this.program });

    this.attachEvents();
    this.resize();
    this.updateGradient();
    this.animate(performance.now());
  }

  animTypeIndex() {
    return { rotate: 0, rotate3d: 1, hover: 2 }[this.opts.animationType] ?? 1;
  }

  attachEvents() {
    this.resizeObserver = new ResizeObserver(() => this.resize());
    this.resizeObserver.observe(this.container);

    this.pointerHandler = (e) => {
      const rect = this.container.getBoundingClientRect();
      const x = (e.clientX - rect.left) / Math.max(rect.width, 1);
      const y = (e.clientY - rect.top) / Math.max(rect.height, 1);
      this.mouseTarget[0] = Math.min(Math.max(x, 0), 1);
      this.mouseTarget[1] = Math.min(Math.max(y, 0), 1);
    };
    this.container.addEventListener("pointermove", this.pointerHandler, { passive: true });

    this.intersectionObserver = new IntersectionObserver((entries) => {
      this.visible = entries[0]?.isIntersecting ?? true;
    });
    this.intersectionObserver.observe(this.container);
  }

  resize() {
    const width = this.container.clientWidth || 1;
    const height = this.container.clientHeight || 1;
    this.renderer.setSize(width, height);
    const gl = this.renderer.gl;
    this.program.uniforms.uResolution.value = [gl.drawingBufferWidth, gl.drawingBufferHeight];
    const ox = (this.opts.offset.x / 100) * width;
    const oy = (this.opts.offset.y / 100) * height;
    this.program.uniforms.uOffset.value = [ox, oy];
  }

  updateGradient() {
    const gl = this.renderer.gl;
    const colors = this.opts.colors.slice(0, 64);
    const count = colors.length;
    const data = new Uint8Array(Math.max(count, 1) * 4);

    if (count === 0) {
      data.set([255, 255, 255, 255]);
    } else {
      colors.forEach((color, idx) => {
        const [r, g, b, a] = colorStringToVec4(color).map((v) => Math.round(v * 255));
        data.set([r, g, b, a], idx * 4);
      });
    }

    const tex = this.gradientTex;
    tex.image = data;
    tex.width = Math.max(count, 1);
    tex.height = 1;
    tex.minFilter = gl.LINEAR;
    tex.magFilter = gl.LINEAR;
    tex.wrapS = gl.CLAMP_TO_EDGE;
    tex.wrapT = gl.CLAMP_TO_EDGE;
    tex.flipY = false;
    tex.generateMipmaps = false;
    tex.format = gl.RGBA;
    tex.type = gl.UNSIGNED_BYTE;
    tex.needsUpdate = true;

    this.program.uniforms.uColorCount.value = count;
  }

  animate(now) {
    this.raf = requestAnimationFrame((t) => this.animate(t));
    if (!this.visible) {
      return;
    }

    const dt = Math.max(0, now - this.lastFrame) * 0.001;
    this.lastFrame = now;
    this.accumTime += dt;

    const frameInterval = 1000 / this.opts.maxFPS;
    if (now - (this.prevRenderTime ?? 0) < frameInterval) {
      return;
    }
    this.prevRenderTime = now;

    if (this.frameSkip++ < this.perf.frameSkip) {
      return;
    }
    this.frameSkip = 0;

    const tau = 0.02 + Math.max(0, Math.min(1, this.opts.hoverDampness)) * 0.5;
    const alpha = 1 - Math.exp(-dt / tau);
    this.mouseSmooth[0] += (this.mouseTarget[0] - this.mouseSmooth[0]) * alpha;
    this.mouseSmooth[1] += (this.mouseTarget[1] - this.mouseSmooth[1]) * alpha;

    this.program.uniforms.uMouse.value = this.mouseSmooth;
    this.program.uniforms.uTime.value = this.accumTime;

    this.renderer.render({ scene: this.mesh });
  }

  dispose() {
    cancelAnimationFrame(this.raf);
    this.resizeObserver?.disconnect();
    this.intersectionObserver?.disconnect();
    this.container.removeEventListener("pointermove", this.pointerHandler);
    try {
      this.container.removeChild(this.renderer.gl.canvas);
    } catch (err) {
      // noop
    }
    this.mesh = null;
    this.program = null;
    this.gradientTex = null;
    if (this.renderer?.gl) {
      this.renderer.gl.getExtension("WEBGL_lose_context")?.loseContext();
    }
    this.renderer = null;
  }
}

export default function PrismaticBurst(props) {
  const containerRef = useRef(null);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return () => {};
    const engine = new PrismEngine(container, props);
    return () => {
      engine?.dispose();
    };
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  return <div className="prismatic-layer" ref={containerRef} />;
}

